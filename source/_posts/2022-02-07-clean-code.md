---
title: 《代码整洁之道》
layout: post
date: 2022-02-07 15:46:43
categories: Reading Notes
tags: Reading Notes
---


```mermaid
graph TD;
    A-->B;
    A-->C;
    B-->D;
    C-->D;
	
```

> 本书提出一种观念：代码质量与其整洁度成正比。

每段代码都该在你希望它所在的地方——如果不在那里，就需要重构了。

如果每个例程都让你感到深合己意，那就是整洁代码。

“代码即设计”和“简单代码”。（感觉与代码自文档化一个意思）

骑自行车的物理学原理，为你证明出骑车完全可行，而且还可以告诉你骑车所需的全部知识。即便如此，你在初次骑车时还是会跌倒在地。（代码的整洁也是需要练习的）

## 整洁代码

我们永远抛不掉代码，因为代码呈现了需求的细节。在某些层面上，这些细节无法被忽略或抽象，必须明确之。将需求明确到机器可以执行的细节程度，就是编程要做的事。而这种规约正是代码。记住，代码确然是我们最终用来表达需求的那种语言。

> 这话可不太中听。怎么会是自作自受呢？难道不关需求的事？难道不关进度的事？难道不关那些蠢经理和没用的营销手段的事？难道他们就不该负点责吗？

（这话需要思考，曾经我认为，高质量的代码和有限的交付时间是存在冲突的，就像鱼和熊掌不可兼得一样。当时的我们，一旦定完上线日期，可能是根据业务发展、战略这些方面定的，既不会减少、简化需求，也不能降低代码的质量，明明上线已经来不及了，还要进行 Code Review，必须 CTO 觉得可以了才能合并代码。那时候我总觉得 CTO 要求太高了，把我们逼的总像被狗撵一样，现在似乎能理解一些了，一旦产生了不好不规范的代码，后面可能就越难越多，直到对代码失去把控能力。）

赶上期限的唯一方法——做得快的唯一方法——就是始终尽可能保持代码整洁。（“始终”这两个字很有意思，代码随时、任何时候都是整洁的，只要出现不整洁了，立马进行处理，这可能能解决一些上面描述的问题，但是对程序员自生的要求可能偏高些，很多程序员估计是做不到这样的。）

什么是整洁的代码？

> 我喜欢优雅和高效的代码。代码逻辑应当直截了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省得引诱别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。整洁的代码力求集中。每个函数、每个类和每个模块都全神贯注于一事，完全不受四周细节的干扰和污染。

> 整洁的代码简单直接。整洁的代码如同优美的散文。

（但是并不推荐如 lodash 中的简洁处理方式，因为可读性差了。）

整洁的代码应可由作者之外的开发者阅读和增补。（Code Review 就是一种方式）

简单代码，依其重要顺序：

- 能通过所有测试；
- 没有重复代码；
- 体现系统中的全部设计理念；
- 包括尽量少的实体，比如类、方法、函数等。

有意义的命名是体现表达力的一种方式，我往往会修改好几次才会定下名字来。（有意义的命名太重要了）

我也会检查对象或方法是否想做的事太多。如果对象功能太多，最好是切分为两个或多个对象。如果方法功能太多，我总是使用抽取手段（ExtractMethod）重构之，从而得到一个能较为清晰地说明自身功能的方法，以及另外数个说明如何实现这些功能的方法。

> 减少重复代码，提高表达力，提早构建简单抽象。这就是我写整洁代码的方法。

读与写花费时间的比例超过10:1。编写代码的难度，取决于读周边代码的难度。（以前从没考虑过写代码的过程还有许多读自己历史代码的时间，现在想想确实如此。）

> 童子军军规：让营地比你来时更干净。

## 有意义的命名

软件中的名称对于软件可读性有90%的作用。你要花时间明智地取名，保持名称有关。名称太重要了，不可随意对待。

- 名副其实
  - 选个好名字要花时间，但省下来的时间比花掉的多
  - 注意命名，而且一旦发现有更好的名称，就换掉旧的
  - 如果名称需要注释来补充，那就不算是名副其实
  - 我们应该选择指明了计量对象和计量单位的名称
- 避免误导
  - 别用accountList来指称一组账号，除非它真的是List类型
  - 提防使用不同之处较小的名称，
    如 XYZControllerForEfficientHandlingOfStrings
    和 XYZControllerForEfficientStorageOfStrings
  - 以同样的方式拼写出同样的概念才是信息（如果是相同意义的东西，命名应该是相同的）
  - 别用小写字母l和大写字母O作为变量名，尤其是在组合使用的时候
- 做有意义的区分
  - 以数字系列命名（a1、a2，……aN）是依义命名的对立面
  - 只要体现出有意义的区分，使用a和the这样的前缀就没错。例如，你可能把a用在域内变量，而把the用于函数参数
  - 废话都是冗余。Variable一词永远不应当出现在变量名中。Table一词永远不应当出现在表名中
  - 要区分名称，就要以读者能鉴别不同之处的方式来区分
    customerInfo与customer没区别；
    getActiveAccount();getActiveAccounts();getActiveAccountInfo(); 不知用哪个
- 使用读得出来的名称
  - 如果名称读不出来，讨论的时候就会像个傻鸟
- 使用可搜索的名称
  - 单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来，e也不是个便于搜索的好变量名
  - 长名称胜于短名称，搜得到的名称胜于用自造编码代写就的名称
  - 名称长短应与其作用域大小相对应。若变量或常量可能在代码中多处使用，则应赋其以便于搜索的名称
- 避免使用编码
  - 把类型或作用域编进名称里面，徒然增加了解码的负担
- 避免思维映射
  - 不应当让读者在脑中把你的名称翻译为他们熟知的名称，如单字母变量 i,j,k
- 类名
  - 类名和对象名应该是名词或名词短语，避免使用Manager、Processor、Data或Info这样的类名
  - 类名不应当是动词
- 方法名
  - 方法名应当是动词或动词短语
  - 属性访问器、修改器和断言应该根据其值命名，并依Javabean标准加上get、set和is前缀
  - 重载构造器时，使用描述了参数的静态工厂方法名
  - 必须查看函数的实现（或文档）才知道它是做什么的，就该换个更好的函数名，或者重新安排功能代码，放到有较好名称的函数中 
- 每个概念对应一个词
  - 给每个抽象概念选一个词，并且一以贯之。例如，使用fetch、retrieve和get来给在多个类中的同种方法命名。
- 别用双关语
  - 避免将同一单词用于不同目的。同一术语用于不同概念，基本上就是双关语了，如 add 和 append
- 使用解决方案领域名称
  - 只有程序员才会读你的代码。所以，尽管用那些计算机科学术语、算法名、模式名、数学术语吧
- 使用源自所涉问题领域的名称
  - 如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称吧
- 添加有意义的语境
  - 用有良好命名的类、函数或名称空间来放置名称，给读者提供语境。如果没这么做，给名称添加前缀就是最后一招了
  - 可以添加前缀addrFirstName、addrLastName、addrState等，以此提供语境。至少，读者会明白这些变量是某个更大结构的一部分
- 不要添加没用的语境
  - 设若有一个名为“加油站豪华版”（GasStationDeluxe）的应用，在其中给每个类添加GSD前缀就不是什么好点子，为什么要搞得IDE没法帮助你
  - 只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境

## 函数

- 短小
  - 函数的第一规则是要短小。第二条规则是还要更短小
  - 函数也不该有100行那么长，20行封顶最佳
  - 函数不应该大到足以容纳嵌套结构
- 只做一件事
  - 函数应该做一件事。做好这件事。只做这一件事
  - 如果函数只是做了该函数名下同一抽象层上的步骤，则函数还是只做了一件事
  - 要判断函数是否不止做了一件事，有一个方法就是看是否能再拆出一个函数
- 每个函数一个抽象层级
  - 自顶向下读代码：向下规则，让每个函数后面都跟着位于下一抽象层级的函数
- switch 语句
  - 将switch语句埋到抽象工厂底下，发挥多态作用
- 使用描述性的名称
  - 函数越短小、功能越集中，就越便于取个好名字
  - 长而具有描述性的名称，要比短而令人费解的名称好
  - 别怕花时间取名字，选择描述性的名称能理清你关于模块的设计思路
  - 命名方式要保持一致
- 函数参数
  - 最理想的参数数量是零，其次是一，再次是二，应尽量避免三
  - 函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了
  - 参数列表，向函数传入数量可变的参数
- 无副作用
  - 副作用是一种谎言。函数承诺只做一件事，但还是会做其他被藏起来的事
- 分隔指令与询问
  - 函数要么做什么事，要么回答什么事，但二者不可得兼
  - 函数应该修改某对象的状态，或是返回该对象的有关信息。两样都干常会导致混乱
- 使用异常替代返回错误码
  - 从指令式函数返回错误码轻微违反了指令与询问分隔的规则，使用异常替代返回错误码，错误处理代码就能从主路径代码中分离出来
  - 最好把try和catch代码块的主体部分抽离出来，另外形成函数，关键字try该是函数的第一个单词，在catch/finally代码块后面也不该有其他内容
  - 使用异常替代错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署
- 别重复自己
  - 重复可能是软件中一切邪恶的根源
  - 面向方面编程（AspectOrientedProgramming）、面向组件编程（ComponentOrientedProgramming）多少也都是消除重复的一种策略
- 结构化编程
  - Dijkstra认为，每个函数、函数中的每个代码块都应该有一个入口、一个出口
- 删除永不调用的函数

## 注释

> “别给糟糕的代码加注释——重新写吧。”

注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。我们总无法找到不用注释就能表达自我的方法，所以总要有注释，这并不值得庆贺。

程序员不能坚持维护注释。真实只在一处地方有：代码。

- 注释不能美化糟糕的代码，用代码来阐述，创建一个描述与注释所言同一事物的函数即可
- 值得编写的注释，也值得好好写
- 好注释
  - 法律信息
  - 提供信息的注释
  - 对意图的解释
  - 阐释，把某些晦涩难明的参数或返回值的意义翻译为某种可读形式
  - 警示，警告其他程序员会出现某种后果
  - TODO注释
- 坏注释
  - 喃喃自语
  - 多余的注释
  - 误导性注释
  - 循规式注释
  - 日志式注释
  - 废话注释，能用函数或变量时就别用注释
  - 位置标记
  - 括号后面的注释
  - 归属与署名
  - 注释掉的代码
  - HTML注释
  - 非本地信息
  - 信息过多
  - 不明显的联系
  - 函数头
  - 非公共代码中的JavaDoc

（commit、branch、tag 个人觉得也应该比较有语义，方便后期想找信息的时候能找到。如果是使用 squash 方式合并的代码，如果原来的分支也删除了，根据试验，可以根据 merge request 的信息，checkout 到指定的 commit，找到想要的信息，再 checkout 回来，也能找到以前提交的所有信息。）

## 格式

先明确一下，代码格式很重要。代码格式不可忽略，必须严肃对待。代码格式关乎沟通，而沟通是专业开发者的头等大事。

（好的代码看上去整洁、一致，有一种优雅的感觉。）

- 垂直格式
  - 大多数为200行、最长500行的单个文件
  - 像报纸学习，名称应当简单且一目了然，最顶部应该给出高层次概念和算法，细节应该往下渐次展开
  - 概念间垂直方向上的区隔，导入声明、函数之间用空行隔开
  - 垂直方向上靠近，则暗示了它们之间的紧密关系
  - 垂直距离，
  - 垂直顺序，被调用的函数应该放在执行调用的函数下面
- 纵向格式
  - 应该尽力保持代码行短小，代码行长度达到100个字符或120个字符
  - 运算符之间的空格
  - 层级缩进
- 团队规范
  - 一组开发者应当认同一种格式风格，每个成员都应该采用那种风格。我们想要让软件拥有一以贯之的风格

## 对象和数据结构

- 数据、对象的反对称性
  - 过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数，但是难以添加新数据结构，因为必须修改所有函数
  - 面向对象代码便于在不改动既有函数的前提下添加新类，但是难以添加新函数，因为必须修改所有类
- 得墨忒耳律
  - 模块不应了解它所操作对象的内部情形
  - 方法不应调用由任何函数返回的对象的方法（链式调用）
- 数据传送对象
  - 只有公共变量、没有函数的类
  - 用在与数据库通信、或解析套接字传递的消息之类场景中

## 错误处理

- 使用异常而非返回码
  - 调用代码很整洁，其逻辑不会被错误处理搞乱
- 先写TryCatchFinally语句
  - try代码块就像是事务，catch代码块将程序维持在一种持续状态
- 使用不可控异常
  - 可控异常的代价就是违反开放/闭合原则
  - 假设某个位于最底层级的函数被修改为抛出一个异常。如果该异常是可控的，则函数签名就要添加throw子句，这意味着每个调用该函数的函数都要修改，捕获新异常
- 给出异常发生的环境说明
  - 你抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所
- 依调用者需要定义异常类
  - 将第三方API打包是个良好的实践手段，封装错误处理，方便改用其它第三方库
- 定义常规流程
  - 不要再异常中处理业务逻辑
  - 使用特例模式，创建一个类或配置一个对象，用来处理特例，客户代码就不用应付异常行为了
- 别返回null值
  - 返回null值，基本上是在给自己增加工作量，也是在给调用者添乱。只要有一处没检查null值，应用程序就会失控
  - 如果你打算在方法中返回null值，不如抛出异常，或是返回特例对象
- 别传递null值

## 类

- 类的组织
  - 自顶向下，公共静态常量，私有静态变量，私有实体变量，公共变量，公共函数，由某个公共函数调用的私有工具函数紧随在该公共函数后面
  - 若同一程序包内的某个测试需要调用一个函数或变量，就会将该函数或变量置为受护或在整个程序包内可访问
- 类应该短小
  - 关于类的第一条规则是类应该短小。第二条规则是还要更短小
  - 类的名称应当描述其权责。命名正是帮助判断类的长度的第一个手段。如果无法为某个类命以精确的名称，这个类大概就太长了
  - 单一权责原则：类或模块应有且只有一条加以修改的理由
  - 内聚，类中的方法和变量互相依赖、互相结合成一个逻辑整体
  - 保持内聚性就会得到许多短小的类
- 为了修改而组织
  - 针对违反单一权责原则的地方进行重新组织
  - 借助接口和抽象类来隔离这些细节带来的影响

## 味道与启发

- 术语“魔术数”不仅是说数字。它泛指任何不能自我描述的符号
  - 在代码中出现原始形态数字通常来说是坏现象，应该用良好命名的常量来隐藏它
  - 有些常量与非常具有自我解释能力的代码协同工作时，易于识别，就不需要命名常量来隐藏了
  - 3.141592653589793之类常数也众所周知，很容易识别。不过，如果直接使用原始形式，却很有可能出错
- 封装条件
  - 应该把解释了条件意图的函数抽离出来
  - 否定式要比肯定式难明白一些。所以，尽可能将条件表示为肯定形式
  - 如level+1出现了多次，应该封装到名为nextLevel之类的变量中的边界条件  

